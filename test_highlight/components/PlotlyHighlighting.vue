<script>
export default {
  
  // Generated by Copilot
  props: {
    viewer_id: {
      type: String,
      default: ''
    },
    show: {
      type: Boolean,
      default: true
    },
    highlight: {
      type: Boolean,
      default: true
    },
    debug: {
      type: Boolean,
      default: false
    },
    
    fillColor: {
      type: String,
      default: 'rgb(0, 0, 0)'
    },
    fillOpacity: {
      type: Number,
      default: 0.5
    },
    strokeColor: {
      type: Number,
      default: 'rgb(120, 120, 255)'
    },
    strokeOpacity: {
      type: Number,
      default: 1
    },
    strokeWidth: {
      type: Number,
      default: 1
    },
    opacity: {
      type: Number,
      default: 1
    },
  },

  data() {
    return {
      el: [],
      hoverDuration: 0,
      debounceTimeout: null,
      debounceTimeout2: null,
      isMouseInside: false,
      eventHandlers: new Map(),
      eventHandler: null,
      originalStyle: new Map(),
      index: 0,
      observer: null,
      container: '',
      trackingElement: document.querySelector('body'),
      showButtons: false,
    }
  },

  async mounted() {
    if (this.show) {
      console.log('%c PlotlyHighlighter buttons are visible', 'color: red; font-weight: bold; font-size: 12px')
    }
    console.log(`mounted PlotlyHighlighter for: ${this.viewer_id}`)
    this.container = `.${this.viewer_id} g.cartesianlayer > g > g.plot`
    this.showButtons = this.show
    // setup the highlighting immediately
    let checkDuration = 200 // 60 * 1000 // 60 seconds
    const interval = setInterval(() => {
      const els = this.queryElements()
      if (els.length > 0) {
        console.log(`there are ${els.length} elements`)
        clearInterval(interval)
        this.redo()
      }
      checkDuration -= 100
      if (checkDuration <= 0) {
        console.error('%c No elements found for PlotlyHighlighter', 'color: red; font-weight: bold; font-size: 18px')
        this.showButtons = this.debug
        clearInterval(interval)
      }
    }, 100);
    
  },

  methods: {
    // document.querySelector("g.cartesianlayer > g > g.plot > g.barlayer.mlayer")
    queryElements() {
      return document.querySelectorAll(`${this.container} > g.barlayer2.mlayer > g > g > g > path`)
    },
    
    queryElementByIndex(index) {
      return document.querySelector(`path[data-index='${index}']`)
    },
    
    // Generated by Copilot
    async getElements() {
      return new Promise((resolve, reject) => {
      let el = [];
      let found = false;
      
      const process = (element, index) => {
        element.style.pointerEvents = 'none';
        element.setAttribute('data-index', index);
        this.originalStyle.set(element, { style: element.style.cssText });
      };

      const interval = setInterval(() => {
        el = this.queryElements();
        if (el.length > 0) {
        console.log(`found ${el.length} elements`)
        found = true;
        this.el = el;
        clearInterval(interval);
        this.el.forEach(process);
        resolve(this.el);
        }
      }, 100);

      // Set a timeout to reject the promise if elements are not found within a certain time limit
      setTimeout(() => {
        clearInterval(interval);
        if (!found) {
        console.error('Elements not found within the time limit')
        reject(new Error('Elements not found within the time limit'));
        }
      }, 10000); // 10 seconds time limit
      });
    },
    
    checkElements() {
      for (element in this.el) {
        const index = element.dataset.index;
        if (index) {
          el = this.queryElementByIndex(index)
          if (el === null) {
            return false
          }
        }
      }
      return true
    },
    
    setupMutationObserver() {
      
      // this layer 
      let watchNode = document.querySelector(`${this.container} > g.barlayer2.mlayer`)
      
      if (watchNode === undefined || watchNode === null) {
        console.error('watch node is none')
        return
      }
      watchNode = watchNode.parentNode
      
      // Observer options
      const config = {attributes: true, childList: true, subtree: true}

      
      const callback = (mutationsList, observer) => {
        // Debounce the redo operation on mutation
        clearTimeout(this.debounceTimeout2);
        this.debounceTimeout2 = setTimeout(() => {
          for (let mutation of mutationsList) {
            // Check for path changes or node additions/removals
            if (
              (mutation.type === 'attributes' && mutation.attributeName === 'd') ||
              (mutation.type === 'childList' && 
              (mutation.addedNodes.length > 0 || mutation.removedNodes.length > 0))
            ) {
              observer.disconnect()
              this.observer = null
              this.redo();
              break;
            }
          }
        }, 50); // 50ms debounce
      }

      // Create an observer instance linked to the callback function
      this.observer = new MutationObserver(callback);
      this.observer.observe(watchNode, config);
    },
    

    highlightElement(element) {
      element.style.fill = this.fillColor
      element.style.fillOpacity = `${this.fillOpacity}`;
      element.style.stroke = this.strokeColor
      element.style.strokeOpacity = `${this.strokeOpacity}`;
      element.style.strokeWidth = `${this.strokeWidth}`;
      element.style.opacity = `${this.opacity}`;
    },
    
    unhighlightElement(element) {
      if (this.originalStyle.get(element)) {
        element.style.cssText = this.originalStyle.get(element).style;
      } else {
        element.style.fill = 'rgb(0,0,0)';
        element.style.fillOpacity = '0';
        element.style.stroke = 'rgb(0, 0, 0)';
        element.style.strokeOpacity = '0';
      }
    },
    
    
    applyListeners() {      
      let currentlyHighlighted = null;
      let ticking = false;
      this.trackingElement = document.querySelector(`.${this.viewer_id}`)
      
      
      const trackMouse = (e) => {
        if (ticking) {
          return;
        }
        ticking = true;
        
        // console.log('tracking mouse')
        window.requestAnimationFrame(() => {
          let foundHighlighted = false;

          for (let element of this.el) {
            const rect = element.getBoundingClientRect();
            const isInside = (
              e.clientX > rect.left &&
              e.clientX < rect.right &&
              e.clientY >= rect.top &&
              e.clientY <= rect.bottom
            );
            
            if (isInside) {
              foundHighlighted = true;
              if (element !== currentlyHighlighted) {
                if (currentlyHighlighted !== null) {
                  this.unhighlightElement(currentlyHighlighted);
                }
                this.highlightElement(element);
                currentlyHighlighted = element;
              }
            }
          }
          
          if (!foundHighlighted && currentlyHighlighted !== null) {
            this.unhighlightElement(currentlyHighlighted);
            currentlyHighlighted = null;
          }
          if (!foundHighlighted) {
            currentlyHighlighted = null;
          }

          ticking = false;
        });
      }
      // Store handler for cleanup
      this.eventHandler = trackMouse;
      this.trackingElement.addEventListener('mousemove', trackMouse);

      this.setupMutationObserver();
    },

    removeListeners() {
      if (this.eventHandler) {
        this.trackingElement.removeEventListener('mousemove', this.eventHandler);
        this.eventHandler = null;
      }
    },


    redo() {
      this.removeListeners()
      if (this.highlight) {
        this.getElements().then(() => {
          this.applyListeners()
        }).catch((error) => {
          console.error('Error:', error);
        });
      }
    },

  },
  
  beforeDestroy() {
    this.removeListeners()
    if (this.observer !== null) {
      this.observer.disconnect()
    }
  },
  
  watch: {
    highlight(value) {
      if (value) {
        this.redo()
      } else {
        this.removeListeners()
      }
    },
    
    show(value) {
      this.showButtons = value
    },
    
    viewer_id(value) {
      this.redo()
    }
    
  }
}

</script>

<template>
  <!-- For debugging only -->
  <v-col v-if="showButtons">
    Plotly Highlighting:
    <v-btn variant="outlined" @click="redo">Re-apply Highlighting</v-btn>
    <v-btn variant="outlined" @click="highlight = !highlight">Toggle Highlighting</v-btn>
  </v-col>
</template>
