<script>
export default {
  
  props: ['viewer_id'],

  data() {
    return {
      el: [],
      hoverDuration: 0,
      debounceTimeout: null,
      debounceTimeout2: null,
      isMouseInside: false,
      // create a map to store the eventhandler for removal
      eventHandlers: new Map(),
      originalStyle: new Map(),
      index: 0,
      observer: null,
      container: '',
      msg: '',
      show: true,
    }
  },

  async mounted() {
    console.log(`mounted PlotlyHighlighter for: ${this.viewer_id}`)
    this.container = `.${this.viewer_id} g.cartesianlayer > g > g.plot`
    
    // setup the highlighting immediately
    const interval = setInterval(() => {
      const els = this.queryElements()
      if (els.length > 0) {
        console.log(`there are ${els.length} elements`)
        clearInterval(interval)
        this.redo()
      }
    }, 100);
    
  },

  methods: {
    
    queryElements() {
      return document.querySelectorAll(`${this.container} > g.barlayer2.mlayer > g > g > g > path`)
    },
    
    queryElementByIndex(index) {
      return document.querySelector(`path[data-index='${index}']`)
    },
    
    // Generated by Copilot
    async getElements() {
      return new Promise((resolve, reject) => {
      let el = [];
      
      const process = (element, index) => {
        element.style.pointerEvents = 'auto';
        element.setAttribute('data-index', index);
        this.originalStyle.set(element, { style: element.style.cssText });
      };

      const interval = setInterval(() => {
        el = this.queryElements();
        if (el.length > 0) {
        this.el = el;
        clearInterval(interval);
        this.el.forEach(process);
        resolve(this.el);
        }
      }, 100);

      // Set a timeout to reject the promise if elements are not found within a certain time limit
      setTimeout(() => {
        clearInterval(interval);
        reject(new Error('Elements not found within the time limit'));
      }, 10000); // 10 seconds time limit
      });
    },
    
    checkElements() {
      for (element in this.el) {
        const index = element.dataset.index;
        if (index) {
          el = this.queryElementByIndex(index)
          if (el === null) {
            return false
          }
        }
      }
      return true
    },
    
    setupMutationObserver() {
      
      // this layer 
      let watchNode = document.querySelector(`${this.container} > g.barlayer2.mlayer`)
      
      if (watchNode === undefined || watchNode === null) {
        console.error('watch node is none')
        return
      }
      watchNode = watchNode.parentNode
      
      // Observer options
      const config = {attributes: true, childList: true, subtree: true}

      
      const callback = (mutationsList, observer) => {
        // Debounce the redo operation on mutation
        clearTimeout(this.debounceTimeout2);
        this.debounceTimeout2 = setTimeout(() => {
          for (let mutation of mutationsList) {
            // Check for path changes or node additions/removals
            if (
              (mutation.type === 'attributes' && mutation.attributeName === 'd') ||
              (mutation.type === 'childList' && 
              (mutation.addedNodes.length > 0 || mutation.removedNodes.length > 0))
            ) {
              observer.disconnect()
              this.observer = null
              this.redo();
              break;
            }
          }
        }, 50); // 50ms debounce
      }

      // Create an observer instance linked to the callback function
      this.observer = new MutationObserver(callback);
      this.observer.observe(watchNode, config);
    },
    
    applyListeners() {
      this.el.forEach(element => {
        let isMouseInside = false;

        const enterHandler = () => {
          if (!isMouseInside) {
            isMouseInside = true;
            element.style.fill = 'rgb(0, 0, 0)';
            element.style.fillOpacity = '0.5';
            element.style.stroke = 'rgb(120, 120, 255)';
            element.style.strokeOpacity = '1';
          }
        }
        

        // Add mouseleave event listener
        const leaveHandler = () => {
          if (isMouseInside) {
            isMouseInside = false;
            if (this.originalStyle.get(element) === undefined) {
              element.style.fill = 'rgb(0,0,0)';
              element.style.fillOpacity = '0';
              element.style.stroke = 'rgb(0, 0, 0)';
              element.style.strokeOpacity = '0';
            }
            element.style.cssText = this.originalStyle.get(element).style;
          }
        }
        
        
        const handler = { enterHandler, leaveHandler };
        this.eventHandlers.set(element, handler);
        
        element.addEventListener('mouseenter', enterHandler);
        element.addEventListener('mouseleave', leaveHandler );
        
        this.setupMutationObserver()
        

      });
      
      
          
      
    },
    
    
    removeListeners() {
      this.el.forEach(element => {
        if (this.eventHandlers.size === 0) return;
        this.el.forEach(element => {
          const handlers = this.eventHandlers.get(element);
          if (handlers) {
            if (handlers.enterHandler) element.removeEventListener('mouseenter', handlers.enterHandler);
            if (handlers.leaveHandler) element.removeEventListener('mouseleave', handlers.leaveHandler);
          }
        });

        this.eventHandlers.clear();
      });
    },

    redo() {
      this.removeListeners()
      this.getElements().then(() => {
        this.applyListeners()
      }).catch((error) => {
        console.error('Error:', error);
      });
    },

  },
  
  beforeDestroy() {
    this.removeListeners()
    if (this.observer !== null) {
      this.observer.disconnect()
    }
  }
}

</script>

<template>
  <v-col v-if="show">
    Plotly Highlighting:
    <v-btn variant="outlined" @click="redo">Redo</v-btn>
  </v-col>
</template>

<style>
button.ph-redo
{
  background-color: white;
  padding: 0.5em 1em;
  border-radius: 5px;
  filter: drop-shadow(0 0px 5px black);

  box-shadow: 0 0 0 black;
  width: fit-content;
}
</style>